// SPDX-License-Identifier: GPL-2.0+
/*
 *  (C) Copyright 2020 Draeger and Licensors, info@draeger.com
 *
 */

#include <common.h>
#include <spi.h>
#include <spi_flash.h>
#include <i2c.h>
#include <i2c_eeprom.h>
#include <post.h>
#include <image.h>
#include <init.h>
#include <linux/delay.h>
#include <watchdog.h>
#include <cpu_func.h>
#include <irq_func.h>
#include <fpga.h>
#include <net.h>
#include <u-boot/crc.h>
#include <dm/uclass.h>
#include <asm/system.h>
#include <asm/io.h>
#include <asm/gpio.h>
#include <asm/arch/reset_manager.h>
#include <mach/system_manager.h>
#include <linux/ctype.h>
#include "../common/draeger_m48_pmstruct.h"
#include "../common/draeger_common.h"

#include "qts/reset_config.h"

#ifndef DO_DEPS_ONLY
#include "generated/version_autogenerated.h"
#endif

#define CONFIG_GPIO_BOARD_COLD_RESET 61 /* external cold reset GPIO61 */
#define CONFIG_GPIO_BOARD_WARM_RESET 24 /* external warm reset FPGA_LOANIO24 */
#define CONFIG_GPIO_DEBUG            59 /* Jumper 1 switch serial output on/off */

#define CONFIG_GPIO_FPGA_PRESENT     87 /* notify uP1 about loaded FPGA
                                           access is only possible when FPGA is loaded !
                                           only write access possible, because it is a Altera Avalon GPIO
                                           not a DesignWare GPIO, read shows wrong value */
#define CONFIG_I2C_DEV_TYPE_OFF 0


/* absolute ballpark figure for time offset in ms up to the internal clock is running */
#define ABS_TIME_OFFSET 450

#define MAX_PRELOADER_VERSION_SIZE 30

#define FPGA_ADDR               0x02000000
#define FPGA_FILE_NAME          "m48_default_system.img"
#define FDT_ADDR                0xf000000
#define FDT_FILE_NAME           "altsoc-m48.dtb"
#define DEVICE_TYPE_MNEMONIC    7
#define DEVICE_TYPE_DEFAULT     "M48Test"

#define BOOTROM_VERSION_OFFSET      0x08
#define BOOTROM_RSTMGR_STAT_OFFSET  0x38

#define SYSMGR_BOOTINFO             (SOCFPGA_SYSMGR_ADDRESS + 0x14)
#define SYSMGR_BOOTINFO_CSEL_LSB    3
#define SYSMGR_BOOTINFO_CSEL_MASK   0x18
#define SYSMGR_BOOTINFO_BSEL_MASK   0x7

/* FPGA interface group */
#define SYSMGR_FPGAINTF_MODULE      (SOCFPGA_SYSMGR_ADDRESS + 0x28)

#define SDR_CTRLGRP_FPGAPORTRST_ADDRESS 0x5080

#define RSTMGR_CTRL_SWWARMRSTREQ_LSB 1
#define RSTMGR_PERMODRST_OSC1TIMER0_LSB 8

#define RSTMGR_STAT_L4WD1RST_MASK 0x00008000
#define RSTMGR_STAT_L4WD0RST_MASK 0x00004000
#define RSTMGR_STAT_MPUWD1RST_MASK 0x00002000
#define RSTMGR_STAT_MPUWD0RST_MASK 0x00001000
#define RSTMGR_STAT_SWWARMRST_MASK 0x00000400
#define RSTMGR_STAT_FPGAWARMRST_MASK 0x00000200
#define RSTMGR_STAT_NRSTPINRST_MASK 0x00000100
#define RSTMGR_STAT_SWCOLDRST_MASK 0x00000010
#define RSTMGR_STAT_CONFIGIOCOLDRST_MASK 0x00000008
#define RSTMGR_STAT_FPGACOLDRST_MASK 0x00000004
#define RSTMGR_STAT_NPORPINRST_MASK 0x00000002
#define RSTMGR_STAT_PORVOLTRST_MASK 0x00000001
#define RSTMGR_WARMRST_MASK (\
    RSTMGR_STAT_L4WD1RST_MASK | \
    RSTMGR_STAT_L4WD0RST_MASK | \
    RSTMGR_STAT_MPUWD1RST_MASK | \
    RSTMGR_STAT_MPUWD0RST_MASK | \
    RSTMGR_STAT_SWWARMRST_MASK | \
    RSTMGR_STAT_FPGAWARMRST_MASK | \
    RSTMGR_STAT_NRSTPINRST_MASK)
#define RSTMGR_COLDRST_MASK (\
    RSTMGR_STAT_SWCOLDRST_MASK | \
    RSTMGR_STAT_CONFIGIOCOLDRST_MASK | \
    RSTMGR_STAT_FPGACOLDRST_MASK | \
    RSTMGR_STAT_NPORPINRST_MASK | \
    RSTMGR_STAT_PORVOLTRST_MASK)

#define RSTMGR_FPGA_DMA0		RSTMGR_DEFINE(2, 0)
#define RSTMGR_FPGA_DMA1		RSTMGR_DEFINE(2, 1)
#define RSTMGR_FPGA_DMA2		RSTMGR_DEFINE(2, 2)
#define RSTMGR_FPGA_DMA3		RSTMGR_DEFINE(2, 3)
#define RSTMGR_FPGA_DMA4		RSTMGR_DEFINE(2, 4)
#define RSTMGR_FPGA_DMA5		RSTMGR_DEFINE(2, 5)
#define RSTMGR_FPGA_DMA6		RSTMGR_DEFINE(2, 6)
#define RSTMGR_FPGA_DMA7		RSTMGR_DEFINE(2, 7)

#define RSTMGR_CTRL_SDRSELFREFEN_MASK	0x00000010
#define RSTMGR_CTRL_FPGAHSEN_MASK		0x00010000
#define RSTMGR_CTRL_ETRSTALLEN_MASK		0x00100000

#define SOCFPGA_RESET_BIT(_reset) CONFIG_HPS_RESET_ASSERT_##_reset << RSTMGR_RESET(SOCFPGA_RESET(_reset))



struct socfpga_reset_manager {
    u32 status;
    u32 ctrl;
    u32 counts;
    u32 padding1;
    u32 mpu_mod_reset;
    u32 per_mod_reset;
    u32 per2_mod_reset;
    u32 brg_mod_reset;
    u32 misc_mod_reset;
    u32 padding2;
    u32 padding3;
    u32 padding4;
    u32 mpu_warm_reset;
    u32 per_warm_reset;
    u32 per2_warm_reset;
};

struct splHandoverT {
        char preloaderVersion[MAX_PRELOADER_VERSION_SIZE];
};

DECLARE_GLOBAL_DATA_PTR;

#ifdef CONFIG_SPL_BUILD
#include <spl.h>
static u32 rst_mgr_status __section(".data");
#endif

PmBootData* m48PmData = (PmBootData*) CFG_SYS_PMSTRUCT_ADDR;
/* create handover structure in OCRAM behind bootData */
struct splHandoverT * splHandoverData = (struct splHandoverT*)  (((PmBootData*) CFG_SYS_PMSTRUCT_ADDR) + 1);


unsigned int silentBootIsRequired(void)
{
    unsigned int  isRequired = 1;

    if (!gpio_request(CONFIG_GPIO_DEBUG, "debug") &&
        gpio_get_value(CONFIG_GPIO_DEBUG) == 0) {
        isRequired = 0;
    }
    return isRequired;
}

#define CONFIG_SYS_QSPI_READ_BUF_SIZE 28
#define CONFIG_SYS_QSPI_CUSTOM_AREA_OFFSET 0x120000
#define CONFIG_SYS_QSPI_BOARD_REV_OFFSET 28
#define CONFIG_SF_DEFAULT_SPEED 1000000

int post_bootmode_get(unsigned int *last_test);


void storeM48UbootVersion(void)
{
    unsigned long reg;
    char *vers;
    const char *token = "-draeger_";
    vers = strstr(U_BOOT_VERSION, token);

#ifdef CONFIG_SPL_BUILD
    int post_boot_mode;

#if defined(BUILD_TAG)
    const char *global_build_id = BUILD_TAG;
#else
    const char *global_build_id = "private";
#endif
    strncpy(splHandoverData->preloaderVersion, global_build_id, sizeof(splHandoverData->preloaderVersion));

    vers += 9; /* strlen(token); */
    snprintf((char*)m48PmData->uboot_version, sizeof(m48PmData->uboot_version), "SPL %s,", vers);

    post_boot_mode = post_bootmode_get(0);
    if (post_boot_mode == 0 ||
            (post_boot_mode & (POST_POWERON | POST_POWERTEST)) ==
                    (POST_POWERON | POST_POWERTEST)) {
        m48PmData->startType = M48_START_TYPE_POWERUP;
    } else {

        if (rst_mgr_status & RSTMGR_WARMRST_MASK) {
            m48PmData->startType = M48_START_TYPE_WARM_REBOOT;
        } else {
            m48PmData->startType = M48_START_TYPE_COLD_REBOOT;
        }
    }
#else
    int len;

    m48PmData->timestamp_kernelloaded = CFG_SYS_ABS_TIME_OFFSET;
    m48PmData->bootmode = 0;

    vers += 1;
    len = strnlen((char*) m48PmData->uboot_version, sizeof(m48PmData->uboot_version));
    if (len > 16) len = 16;
    memcpy(m48PmData->uboot_version + len, vers, 32 - len);
    m48PmData->uboot_version[sizeof(m48PmData->uboot_version)-1] = '\0';
#endif

    updateM48PmStructChecksum();

    /*
     * Clear fake OCRAM ECC first as SBE
     * and DBE might triggered during power on
     */
    reg = readl(socfpga_get_sysmgr_addr() + SYSMGR_GEN5_ECCGRP_OCRAM);
    if (reg & SYSMGR_ECC_OCRAM_SERR)
        writel(SYSMGR_ECC_OCRAM_SERR | SYSMGR_ECC_OCRAM_EN,
               socfpga_get_sysmgr_addr() + SYSMGR_GEN5_ECCGRP_OCRAM);
    if (reg & SYSMGR_ECC_OCRAM_DERR)
        writel(SYSMGR_ECC_OCRAM_DERR  | SYSMGR_ECC_OCRAM_EN,
               socfpga_get_sysmgr_addr() + SYSMGR_GEN5_ECCGRP_OCRAM);

}


#ifndef CONFIG_SPL_BUILD

int read_mac_from_eeprom(void)
{
    uchar buf[CONFIG_SYS_QSPI_READ_BUF_SIZE] = {0};
    char str[18];
    unsigned int crc = 0;
    uint32_t crc_buf;
    struct spi_flash *flash;
    int ret;

    flash = spi_flash_probe(0, 0, CONFIG_SF_DEFAULT_SPEED, SPI_MODE_3);
    if (flash == NULL) {
        printf("Failed to initialize QSPI flash at 0:0 (error %d)\n", ret);
        return 1;
    } else {
        ret = spi_flash_read(flash, CONFIG_SYS_QSPI_CUSTOM_AREA_OFFSET, CONFIG_SYS_QSPI_READ_BUF_SIZE, buf);
        if (ret)
            return printf("QSPI Flash read failed");
        else {
            memcpy(&crc_buf, &buf[24], sizeof(uint32_t));

            if (crc32(crc, buf, 24) == crc_buf)
            {

                printf("Reading MAC from EEPROM\n");
                if (memcmp(buf, "\0\0\0\0\0\0", 6))
                {
                    sprintf(str,
                        "%02X:%02X:%02X:%02X:%02X:%02X",
                        buf[0], buf[1],
                        buf[2], buf[3],
                        buf[4], buf[5]);
                    env_set("ethaddr", str);
                }

            }
            else
            {
                printf("QSPI MAC CRC failed\n");
            }
        }
    }

    spi_flash_reset(flash);

    return 0;
}

static int do_setmacaddr (struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])

{
    unsigned int offset = 0;
    uchar *buf;
    unsigned char str[18];
    uint32_t crc_buf;
    struct spi_flash *spi_flash;
    int ret;

    if (argc != 3)
        return 1;

    if ((offset = simple_strtoul(argv[1], NULL, 10)) > 3)
    {
        printf ("MAC offset %d too high (valid values 0 -3)\n", offset);
        return 1;
    }

    string_to_enetaddr (argv[2], str);

    spi_flash = spi_flash_probe(0, 0, CONFIG_SF_DEFAULT_SPEED, SPI_MODE_3);
    if (spi_flash == NULL) {
        printf("Failed to initialize QSPI flash at 0:0 (error %d)\n", ret);
        return 1;
    }

    buf = (uchar *)malloc (spi_flash->erase_size);
    if (NULL == buf)
    {
        printf ("setmacaddr: Could not allocate read buffer\n");
        return 1;
    }
    /* Read MAC addresses from QSPI Flash */
    ret = spi_flash_read(spi_flash, CONFIG_SYS_QSPI_CUSTOM_AREA_OFFSET, spi_flash->erase_size, buf);

    if (ret) {
        printf("QSPI Flash read failed\n");
        goto error_free_mac_buf;
    }

    memcpy(&crc_buf, &buf[24], sizeof(uint32_t));
    if (crc32(0, buf, 24) != crc_buf)
    {
        printf ("The QSPI Flash MAC area is corrupted...erasing\n");
        memset (buf, 0xFF, 28);
    }

    memcpy ((void *)(buf + 6 * offset), (void *)str, 6);
    crc_buf = crc32(0, buf, 24);
    memcpy ((void *)(buf + 24), (void *)(&crc_buf), sizeof(uint32_t));

    ret = spi_flash_erase(spi_flash, CONFIG_SYS_QSPI_CUSTOM_AREA_OFFSET, spi_flash->erase_size);
    if (ret) {
        printf("QSPI Flash erase failed");
        goto error_free_mac_buf;
    }

    ret = spi_flash_write(spi_flash, CONFIG_SYS_QSPI_CUSTOM_AREA_OFFSET, spi_flash->erase_size, buf);
    if (ret) {
        printf("QSPI Flash write failed: %d\n", ret);
        goto error_free_mac_buf;
    }

    printf("MAC %s was written at offset %d\n", argv[2], offset);
    free (buf);
    spi_flash_reset(spi_flash);

    /***** return success ****/
    return 0;

error_free_mac_buf:

    free (buf);
    return 1;
}

U_BOOT_CMD(
        setmacaddr, 3,  1,  do_setmacaddr,
        "Set one of the 4 MAC addresses in QSPI Flash.",
        "Set one of the 4 MAC addresses in QSPI Flash. \n"
        "Only 4 MAC adresses can be written in QSPI Flash \n"
        "The one at offset 0 will be used as the interface MAC \n"
        "setmacaddr offset value"
);

static int do_boardrev (struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
{
    uint16_t ver;
    struct spi_flash *flash;
    int ret;

    flash = spi_flash_probe(0, 0, CONFIG_SF_DEFAULT_SPEED, SPI_MODE_3);
    if (flash == NULL) {
        printf("Failed to initialize QSPI flash at 0:0 (error %d)\n", ret);
        return 1;
    }

    /* Read board revision from QSPI Flash */
    ret = spi_flash_read(flash, CONFIG_SYS_QSPI_CUSTOM_AREA_OFFSET + CONFIG_SYS_QSPI_BOARD_REV_OFFSET,
            2, &ver);

    if (ret) {
        printf("QSPI Flash read failed\n");
    } else {
        printf ("Board revision %d.%d\n", *((char *)(&ver)), *((char *)(&ver) + 1));
    }
    spi_flash_reset(flash);
    return 0;
}

U_BOOT_CMD(
    boardrev,   1,  1,  do_boardrev,
    "Board Revision Number.",
    "Board Revision Number. \n"
    "boardrev"
);

static int do_setboardrev (struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
{
    uchar * buf;
    struct spi_flash *spi_flash;
    int ret;

    if (argc != 3) {
        printf("Error! wrong number of parameters\n");
        return 1;
    }

    if (simple_strtoul(argv[1], NULL, 10) > 0xff || simple_strtoul(argv[2], NULL, 10) > 0xff)
    {
        printf ("Major or Minor numbers must be lower than 255\n");
        return 1;
    }

    spi_flash = spi_flash_probe(0, 0, CONFIG_SF_DEFAULT_SPEED, SPI_MODE_3);

    buf = (uchar *)malloc (spi_flash->erase_size);
    if (NULL == buf)
    {
        printf ("do_setboardrev: Could not allocate read buffer\n");
        return 1;
    }
    /* Read MAC addresses from QSPI Flash */
    ret = spi_flash_read(spi_flash, CONFIG_SYS_QSPI_CUSTOM_AREA_OFFSET, spi_flash->erase_size, buf);

    if (ret) {
        printf("QSPI Flash read failed\n");
        goto error_free_revision_buf;
    }

    buf[CONFIG_SYS_QSPI_BOARD_REV_OFFSET] = (unsigned char)simple_strtoul(argv[1], NULL, 10);
    buf[CONFIG_SYS_QSPI_BOARD_REV_OFFSET + 1] = (unsigned char)simple_strtoul(argv[2], NULL, 10);

    /* Update board revision in QSPI Flash */
    ret = spi_flash_erase(spi_flash, CONFIG_SYS_QSPI_CUSTOM_AREA_OFFSET, spi_flash->erase_size);
    if (ret) {
        printf("QSPI Flash erase failed");
        goto error_free_revision_buf;
    }

    ret = spi_flash_write(spi_flash, CONFIG_SYS_QSPI_CUSTOM_AREA_OFFSET, spi_flash->erase_size, buf);
    if (ret) {
        printf("QSPI Flash write failed: %d\n", ret);
        goto error_free_revision_buf;
    }

    printf("Board revision %d.%d was written in QSPI at offset %d\n",
            buf[CONFIG_SYS_QSPI_BOARD_REV_OFFSET],
            buf[CONFIG_SYS_QSPI_BOARD_REV_OFFSET + 1],
            CONFIG_SYS_QSPI_BOARD_REV_OFFSET);

    free (buf);
    spi_flash_reset(spi_flash);

    /***** return success ****/
    return 0;

error_free_revision_buf:

    free (buf);
    return 1;
}

U_BOOT_CMD(
    setboardrev,    3,  1,  do_setboardrev,
    "Set Board Revision Number.",
    "Set Board Revision Number. \n"
    "setboardrev major minor"
);

char* get_conf_name(void) {
    char *conf_name  = NULL;
    char *conf_name_env = env_get("conf_name");

    if (check_name(conf_name_env, CMD_BUF_SIZE)) {
        conf_name = conf_name_env;
    } else {
        conf_name = "m48soc";
    }
    return conf_name;
}

const char * get_ftd_name(void)
{
    return FDT_FILE_NAME;
}

int getBootMmcDevice(void)
{
    return 0;
}

/* EEPROM Configuration */
#define CONFIG_SYS_EEPROM_BUS_NUM  0 /* i2c0 */

static int do_get_device_type (struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
{

    int ret;
    PmBootData* data;
    data = (PmBootData*) CFG_SYS_PMSTRUCT_ADDR;
    char buf[M48_DEVICE_TYPE_SIZE + 1];
    struct udevice *dev;
    int i;

    ret = i2c_get_chip_for_busnum(CONFIG_SYS_EEPROM_BUS_NUM,
        CONFIG_SYS_I2C_EEPROM_ADDR, 1, &dev);

    /* Read device type from EEPROM */
    if (!ret)
        ret = dm_i2c_read(dev, CONFIG_I2C_DEV_TYPE_OFF, (uchar *) buf, M48_DEVICE_TYPE_SIZE);

    if (ret) {

        printf("\nEEPROM @ 0x%02x read @ 0x%02x FAILED!!!\n",
            CONFIG_SYS_I2C_EEPROM_ADDR, CONFIG_I2C_DEV_TYPE_OFF);
        return ret;

    } else {
        memcpy(data->device_type, buf, M48_DEVICE_TYPE_SIZE);

        for (i=0; i<DEVICE_TYPE_MNEMONIC; i++) {
            if (!isprint(buf[i]))
                buf[i] = '\0';
        }
        buf[DEVICE_TYPE_MNEMONIC] = '\0';
        printf("device type '%s'\n", buf);

    }
    return 0;
}

U_BOOT_CMD(
    devtype, 1,  1,  do_get_device_type,
    "Store device type.",
    "Read device type from EEPROM and set into post mortem boot data.\n"
    "getdevtype"
);

static int check_device_type (unsigned int offset)
{
    PmBootData* data = (PmBootData*) CFG_SYS_PMSTRUCT_ADDR;
    char *image_name;
    char printb[DEVICE_TYPE_MNEMONIC + 1];
    int i;

    struct image_header *header;
    header = (struct image_header *) offset;

    if (image_get_magic(header) == IH_MAGIC) {
        image_name = image_get_name(header);

        for (i=0; i<DEVICE_TYPE_MNEMONIC; i++) {
            if (isprint(image_name[i]))
                printb[i] = image_name[i];
            else
                printb[i] = '\0';
        }
        printb[DEVICE_TYPE_MNEMONIC] = '\0';
        printf("FPGA type '%s'\n", printb);

        if ( (memcmp(image_name, data->device_type, DEVICE_TYPE_MNEMONIC) == 0) ||
                (memcmp(image_name, DEVICE_TYPE_DEFAULT, DEVICE_TYPE_MNEMONIC) == 0)) {
            return 0;
        }
    }

    return 1;
}

static int do_check_device_type (struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
{
    return check_device_type(simple_strtoul(argv[1], NULL, 16));
}

U_BOOT_CMD(
    cktype, 2,  1,  do_check_device_type,
    "Check device type vs. FPGA type.",
    "Check the device type in the post mortem boot data vs. FPGA device header.\n"
    "checkdevtype imageaddress"
);

static int enableFPGA(void)
{
    if (run_command("bridge enable", 0)) return -1;

    /* fpgasecurityregl4main = fpgasecurity_allenabled */
    /* for (i=0; i<32; i++)  writel(0xffffffff, ((unsigned long*) FPGA_SECURITY_L4_MAIN) + i); */
    if (run_command("mw.l FF800008 FFFFFFFFF 32", 0)) return -1;

    return 0;
}

static int loadFPGA(void)
{
    if (do_get_device_type (NULL, 0, 0, NULL)) return -1;
    if (check_device_type (FPGA_ADDR)) return -1;

    snprintf(cmdbuf, CMD_BUF_SIZE, "bridge disable");
    if (run_command(cmdbuf, 0)) return -1;

    snprintf(cmdbuf, CMD_BUF_SIZE, "fpga loadmk 0 %x", FPGA_ADDR);
    if (run_command(cmdbuf, 0)) return -1;

    return enableFPGA();
}


int load_extra_images_from_partition(int partition)
{
    char *imagepath = get_image_path(IMAGE_PATH);

    snprintf(cmdbuf, CMD_BUF_SIZE, "fatload mmc " __stringify(CONFIG_SYS_MMC_ENV_DEV) ":%d %x %s/" FPGA_FILE_NAME,
        partition, FPGA_ADDR, imagepath);

    if (run_command(cmdbuf, 0)) return -1;

    if (loadFPGA ()) return -1;

    return 0;
}

int load_extra_images_from_tftp(void)
{
    char *imagepath = get_image_path(IMAGE_PATH);

    snprintf(cmdbuf, CMD_BUF_SIZE, "tftp %x %s/" FPGA_FILE_NAME, FPGA_ADDR, imagepath);
    if (run_command(cmdbuf, 0)) return -1;

    if (loadFPGA ()) return -1;

    return 0;
}

int start_itb_image(void)
{
    char *conf_name = NULL;

    if (genimg_get_format((const void*) CONFIG_SYS_LOAD_ADDR) != IMAGE_FORMAT_FIT) return -1;

    conf_name = get_conf_name();

    /*  We need to provide the correct addresss here, because bootm will uses $loadaddr,
        which points to the address of the previously loaded FPGA */
    snprintf(cmdbuf, CMD_BUF_SIZE, "bootm %lx%s%s", (ulong)CONFIG_SYS_LOAD_ADDR,
        conf_name ? "#" : "", conf_name ? conf_name : "");
    if (run_command(cmdbuf, 0)) return -1;
    return 0;
}

int start_kernel_image(ulong kernel_size, ulong fdt_size)
{
    if (fdt_size == 0) /* no fdt_size given --> fit image */
        return start_itb_image();
    else
        return start_legacy_image();
}

int check_preloader_version_string(const char *pVersion)
{
    size_t ver_str_len = strnlen(pVersion, MAX_PRELOADER_VERSION_SIZE);
    size_t currentChar = 0;
    if((ver_str_len == MAX_PRELOADER_VERSION_SIZE) || !ver_str_len)
    {
        return 1;
    }
    for(currentChar = 0; currentChar < ver_str_len; ++currentChar)
    {
        if(!isprint((int)*(pVersion+currentChar)))
        {
            return 1;
        }
    }
    return 0;
}

void fdt_fixup_version_info(void *fdt)
{
#if defined(BUILD_TAG)
    const char *global_build_id = BUILD_TAG;
#else
    const char *global_build_id = "private";
#endif
    if(check_preloader_version_string(splHandoverData->preloaderVersion))
    {
        printf("Preloader version string not found in OCRAM. Skip insertion into DTB\n");
    }
    else
    {
        do_fixup_by_path(fdt, "/alt_soc/boardService", "preloader-version", splHandoverData->preloaderVersion, strlen((const char*) splHandoverData->preloaderVersion) + 1, 1);
    }
    do_fixup_by_path(fdt, "/alt_soc/boardService", "bootloader-version", global_build_id, strlen(global_build_id) + 1, 1);
}

int  ft_board_setup(void *blob, struct bd_info *bd)
{
    /* set size to real, so that vxWorks can use it */
    u64 ram_size  = (u64) get_ram_size((long *)CONFIG_SYS_SDRAM_BASE, (long) PHYS_SDRAM_SIZE);
    gd->bd->bi_dram[0].size = ram_size;

    fdt_fixup_version_info(blob);
    if(silentBootIsRequired()){
        fdt_fixup_serial_output(blob);
    }
    return 0;
}

int display_error_message(void)
{
    printf("Device failure !\n");
    return 1;
}

#ifdef CONFIG_POST

/* time to wait for reboot of uP1 */
#define POST_REMOTE_WAIT_INTERVAL_1  500
/* time to wait for reset triggered by uP1 */
#define POST_REMOTE_WAIT_INTERVAL_2 2000
/* time to wait after triggering reset before set to failure */
#define POST_REMOTE_WAIT_FAILURE    150

#ifdef CONFIG_SYS_POST_BSPEC1
int board_reset_post_test (int flags)
{
    int ints;
    ulong base,time;

    if ((m48PmData->post_board_reset.magic != BRESET_MAGIC) || ((flags & POST_MANUAL) != 0)) {
        /* PowerOn */
        m48PmData->post_board_reset.result = M48_TS_NOT_RUN;
        if ((flags & POST_MANUAL) != 0) {
            m48PmData->post_board_reset.state  = POST_BRESET_STATE_UP2_RESET;
        } else {
            m48PmData->post_board_reset.state  = POST_BRESET_STATE_UP1_RESET;
        }
        m48PmData->post_board_reset.magic  = BRESET_MAGIC;
        /* hack: board_test_run_always() only adds the POST reset test time in case
                 of power on. The timestamp_post is used as a flag to indicate the power on condition */
        m48PmData->timestamp_post = 2 * ABS_TIME_OFFSET;

    }

    /* add time offset up to internal timer runs */
    m48PmData->timestamp_post += ABS_TIME_OFFSET;

    /* add the offset which has been already created by preceeding restarts */
    m48PmData->timestamp_kernelloaded = m48PmData->timestamp_post;

    if (m48PmData->post_board_reset.result == M48_TS_NOT_RUN) {
        switch (m48PmData->post_board_reset.state) {
        case POST_BRESET_STATE_UP1_RESET:
            m48PmData->post_board_reset.state = POST_BRESET_STATE_UP2_RESET;
            updateM48PmStructChecksum();

            post_log("\nhw reset %d test time: %u ms waiting for reboot from other UP", m48PmData->post_board_reset.state, post_time_ms (0));
            base = post_time_ms (0);
            while ((time = post_time_ms (0)) < base + POST_REMOTE_WAIT_INTERVAL_2)
            {
                /* timestamp_kernelloaded holds the timestamp_post after restart */
                m48PmData->timestamp_post = m48PmData->timestamp_kernelloaded + post_time_ms (0);
                flush_dcache_all();
            }
            post_log("hw reset time : %u ms, failed while waiting for reset from other UP ", m48PmData->remoteDelay);

            m48PmData->post_board_reset.result = M48_TS_FAIL;
            m48PmData->timestamp_post = m48PmData->timestamp_kernelloaded;
            updateM48PmStructChecksum();

            return 1;
        case POST_BRESET_STATE_UP2_RESET:
            m48PmData->post_board_reset.state = POST_BRESET_STATE_BOTH_DONE;
            updateM48PmStructChecksum();

            while ((time = post_time_ms (0)) < POST_REMOTE_WAIT_INTERVAL_1) { ; }   /* give other UP time to settle */

            post_log("hw reset %d time: %u ms\n", m48PmData->post_board_reset.state, post_time_ms (0));
            ints = disable_interrupts ();

            m48PmData->timestamp_post = m48PmData->timestamp_kernelloaded + post_time_ms (0);
            flush_dcache_all();

            if ((gpio_request(CONFIG_GPIO_BOARD_COLD_RESET, "cold-reset")) ||
                (gpio_direction_output(CONFIG_GPIO_BOARD_COLD_RESET , 0)) ) {

                post_log("hw reset : failed to access GPIO %u ", CONFIG_GPIO_BOARD_COLD_RESET);
                m48PmData->post_board_reset.result = M48_TS_FAIL;
                updateM48PmStructChecksum();
                return 4;
            } else {
                base = post_time_ms (0);
                while ((time = post_time_ms (0)) < base + POST_REMOTE_WAIT_FAILURE)
                {
                    /* timestamp_kernelloaded holds the timestamp_post after restart */
                    m48PmData->timestamp_post = m48PmData->timestamp_kernelloaded + post_time_ms (0);
                    flush_dcache_all();
                }
                post_log("hw reset time : %u ms, failed while waiting for own reset \n", time);
            }

            /* we should never reach this code if the test succeeds */
            if (ints) { enable_interrupts (); }

            m48PmData->post_board_reset.result = M48_TS_FAIL;
            m48PmData->timestamp_post = m48PmData->timestamp_kernelloaded;
            updateM48PmStructChecksum();

            return 2;

        case POST_BRESET_STATE_BOTH_DONE:
            m48PmData->post_board_reset.result = M48_TS_PASS;
            updateM48PmStructChecksum();
            post_log("remote delay : %u/%u ms ", m48PmData->remoteDelay, POST_REMOTE_WAIT_INTERVAL_2);
            break;

        default:
            post_log("hw reset test out of state ");
            return 3;
        }
    }
    return 0;
}
#endif /* CONFIG_SYS_POST_BSPEC1 */

#ifdef CONFIG_SYS_POST_WATCHDOG

int watchdog_post_test (int flags)
{
    int ints;
    ulong base,time;
    static const struct socfpga_reset_manager *reset_manager_base =
            (void *)SOCFPGA_RSTMGR_ADDRESS;

    /* add the offset which has been already created by preceeding restarts */
    m48PmData->timestamp_kernelloaded = m48PmData->timestamp_post;

    if ((m48PmData->post_watchdog.magic != SYS_WATCHDOG_MAGIC) || ((flags & POST_MANUAL) != 0)) {
        /* PowerOn */
        m48PmData->post_watchdog.magic  = SYS_WATCHDOG_MAGIC;
        m48PmData->post_watchdog.result = M48_TS_NOT_RUN;
        updateM48PmStructChecksum();

        /* this test is part of the reset test in order to avoid an additional
         *  reboot of the board
         */
        initializePMSaveMemory();

        ints = disable_interrupts ();

        /* configure for warm reset */
        setbits_le32(&reset_manager_base->ctrl, (1 << RSTMGR_CTRL_SWWARMRSTREQ_LSB));

        time = base = post_time_ms (0);
        while ((time - base) < 500) {
            m48PmData->timestamp_post = m48PmData->timestamp_kernelloaded + time;
            flush_dcache_all();
            time = post_time_ms (0);
        }

        /* we should never reach this code if the test succeeds */
        if (ints) { enable_interrupts (); }

        m48PmData->post_watchdog.result = M48_TS_FAIL;
        /* reset to value after restart */
        m48PmData->timestamp_post = m48PmData->timestamp_kernelloaded;
        updateM48PmStructChecksum();

        post_log("hw watchdog time : %u ms, failed ", time);
        return 2;

    } else {
        /* No PowerOn -> Reset */
        if (m48PmData->post_watchdog.result == M48_TS_NOT_RUN) {
            m48PmData->post_watchdog.result = M48_TS_PASS;
            /* add time offset up to internal timer runs */
            m48PmData->timestamp_post += CFG_SYS_ABS_TIME_OFFSET;
            m48PmData->timestamp_kernelloaded = m48PmData->timestamp_post;
            updateM48PmStructChecksum();

            checkPMSaveMemory();
        }
    }
    return 0;
}
#endif /* CONFIG_SYS_POST_WATCHDOG */

#endif /* CONFIG_POST */


#else /* #ifndef CONFIG_SPL_BUILD */

void checkWarmstart(void)
{
    int post_boot_mode;
    int i;

    printf("RESET: %08x\n", rst_mgr_status);
    post_boot_mode = post_bootmode_get(0);
    if (0 == post_boot_mode) {
        puts("RESET: POWER_UP\n");
    }  else {
        if (rst_mgr_status & RSTMGR_STAT_NRSTPINRST_MASK)
            puts("RESET: WARM reset from Pin\n");
        if ((rst_mgr_status & RSTMGR_STAT_NPORPINRST_MASK) ||
                (rst_mgr_status & RSTMGR_STAT_SWCOLDRST_MASK))
            puts("RESET: COLD\n");
        else
            puts("RESET: WARM\n");
    }

    if ( !(rst_mgr_status & RSTMGR_STAT_NPORPINRST_MASK))
    {
        /** do not reset the other controller when in POST **/
        if ( post_boot_mode != 0 && ! (post_boot_mode & POST_POWERTEST)) {
            WATCHDOG_RESET();
            puts("reseting uP1\n");
            if (!gpio_request(CONFIG_GPIO_BOARD_COLD_RESET, "cold_rst")) {
                gpio_direction_output(CONFIG_GPIO_BOARD_COLD_RESET, 0);
                for (i=0; i< 800; i++) {
                    udelay(1000);
                }
                WATCHDOG_RESET();
                gpio_direction_output(CONFIG_GPIO_BOARD_COLD_RESET, 1);
                puts("reseting uP1 done\n");
            }
        } else {
            printf("No uP1 reset due to POST %x\n", post_boot_mode);
        }
    }

}

/* Release peripherals from reset based on handoff
 * Release of the devices is part of the device tree now ("reset" property), but as we have to
 * be backward compatible, the reset is done depending of the configured header
 * files in Quartus 14.
 */
void reset_deassert_peripherals_handoff(void)
{
    unsigned val = 0;

    /* permodrst */
    val |= SOCFPGA_RESET_BIT(EMAC0);
    val |= SOCFPGA_RESET_BIT(EMAC1);
    val |= SOCFPGA_RESET_BIT(USB0);
    val |= SOCFPGA_RESET_BIT(USB1);
    val |= SOCFPGA_RESET_BIT(NAND);
    val |= SOCFPGA_RESET_BIT(QSPI);
    val |= SOCFPGA_RESET_BIT(L4WD1);
    val |= SOCFPGA_RESET_BIT(OSC1TIMER1);
    val |= SOCFPGA_RESET_BIT(SPTIMER0);
    val |= SOCFPGA_RESET_BIT(SPTIMER1);
    val |= SOCFPGA_RESET_BIT(I2C0);
    val |= SOCFPGA_RESET_BIT(I2C1);
    val |= SOCFPGA_RESET_BIT(I2C2);
    val |= SOCFPGA_RESET_BIT(I2C3);
    val |= SOCFPGA_RESET_BIT(UART0);
    val |= SOCFPGA_RESET_BIT(UART1);
    val |= SOCFPGA_RESET_BIT(SPIM0);
    val |= SOCFPGA_RESET_BIT(SPIM1);
    val |= SOCFPGA_RESET_BIT(SPIS0);
    val |= SOCFPGA_RESET_BIT(SPIS1);
    val |= SOCFPGA_RESET_BIT(SDMMC);
    val |= SOCFPGA_RESET_BIT(CAN0);
    val |= SOCFPGA_RESET_BIT(CAN1);
    val |= SOCFPGA_RESET_BIT(GPIO0);
    val |= SOCFPGA_RESET_BIT(GPIO1);
    val |= SOCFPGA_RESET_BIT(GPIO2);
    val |= SOCFPGA_RESET_BIT(DMA);
    val |= SOCFPGA_RESET_BIT(SDR);
    writel(val, socfpga_get_rstmgr_addr() + RSTMGR_GEN5_PERMODRST);

    /* permodrst2 */
    val = 0;
    val |= SOCFPGA_RESET_BIT(FPGA_DMA0);
    val |= SOCFPGA_RESET_BIT(FPGA_DMA1);
    val |= SOCFPGA_RESET_BIT(FPGA_DMA2);
    val |= SOCFPGA_RESET_BIT(FPGA_DMA3);
    val |= SOCFPGA_RESET_BIT(FPGA_DMA4);
    val |= SOCFPGA_RESET_BIT(FPGA_DMA5);
    val |= SOCFPGA_RESET_BIT(FPGA_DMA6);
    val |= SOCFPGA_RESET_BIT(FPGA_DMA7);
    writel(val, socfpga_get_rstmgr_addr() + RSTMGR_GEN5_PER2MODRST);


    /* warm reset handshake support */
#if (CONFIG_HPS_RESET_WARMRST_HANDSHAKE_FPGA == 1)
    setbits_le32(socfpga_get_rstmgr_addr() + RSTMGR_GEN5_CTRL, RSTMGR_CTRL_FPGAHSEN_MASK);
#else
    clrbits_le32(socfpga_get_rstmgr_addr() + RSTMGR_GEN5_CTRL, RSTMGR_CTRL_FPGAHSEN_MASK);
#endif

#if (CONFIG_HPS_RESET_WARMRST_HANDSHAKE_ETR == 1)
    setbits_le32(socfpga_get_rstmgr_addr() + RSTMGR_GEN5_CTRL, RSTMGR_CTRL_ETRSTALLEN_MASK);
#else
    clrbits_le32(socfpga_get_rstmgr_addr() + RSTMGR_GEN5_CTRL, RSTMGR_CTRL_ETRSTALLEN_MASK);
#endif

#if (CONFIG_HPS_RESET_WARMRST_HANDSHAKE_SDRAM == 1)
    setbits_le32(socfpga_get_rstmgr_addr() + RSTMGR_GEN5_CTRL, RSTMGR_CTRL_SDRSELFREFEN_MASK);
#else
    clrbits_le32(socfpga_get_rstmgr_addr() + RSTMGR_GEN5_CTRL, RSTMGR_CTRL_SDRSELFREFEN_MASK);
#endif
}

#endif /* CONFIG_SPL_BUILD */



/******************************************************************************
 * u-boot hooks
 *****************************************************************************/

int board_early_init_f(void)
{
    if(silentBootIsRequired())
    {
        gd->flags |= (GD_FLG_SILENT | GD_FLG_DISABLE_CONSOLE);
    }

#ifdef CONFIG_SPL_BUILD
    reset_deassert_peripherals_handoff();
#endif

    return 0;
}

#ifdef CONFIG_SPL_BUILD

void save_boot_params(unsigned long r0, unsigned long r1, unsigned long r2,
              unsigned long r3)
{
    u32 sysmgrBootInfo;
    u32 bootrom_addr = r0;

    rst_mgr_status = 0;

#ifdef DEBUG_SPL_WAIT_FOR_JTAG_DEBUGGER
    volatile ulong debugger_is_attached;
    debugger_is_attached = 0;
    socfpga_per_reset(SOCFPGA_RESET(L4WD0), 1);
    while(debugger_is_attached == 0)
    { /* attach with your debugger and manually set variable to 1 */ }
#endif


    sysmgrBootInfo = readl(SYSMGR_BOOTINFO);

    if ( sysmgrBootInfo & SYSMGR_BOOTINFO_BSEL_MASK) {
        if ( bootrom_addr > 0xffff0000 && bootrom_addr + BOOTROM_RSTMGR_STAT_OFFSET > 0xffff0000 ) {
            rst_mgr_status = readl(bootrom_addr + BOOTROM_RSTMGR_STAT_OFFSET);
        } else {
            rst_mgr_status = (bootrom_addr & ~0xF0000000) + 0xC0000000;
        }
    } else {
        rst_mgr_status = 0x00010000;
    }
    save_boot_params_ret();
}

void board_boot_order(u32 *spl_boot_list)
{
    checkWarmstart();
    storeM48UbootVersion();
    spl_boot_list[0] = BOOT_DEVICE_MMC1;
}

void spl_display_print(void)
{
#if defined(BUILD_TAG)
    puts("Build: " BUILD_TAG "\n");
#endif
}

unsigned int getPhyCfgPresetValue(void)
{
    if (0 == post_bootmode_get(0)) {
        m48PmData->ram_calibration_value = 0xffffffff;
    }
    return m48PmData->ram_calibration_value;
}

void storePhyCfgPresetValue(unsigned int preset)
{
    m48PmData->ram_calibration_value = preset;

    return;
}

#else

/*
 * Print Board information
 */

int checkboard(void)
{
    storeM48UbootVersion();
    return 0;
}

int board_late_init(void)
{
    debug("M48 board_late_init\n");
    read_mac_from_eeprom();

    if (gd->flags & GD_FLG_DISABLE_CONSOLE) m48PmData->verboseBoot = 0;
    else                                    m48PmData->verboseBoot = 1;

    return 0;
}

/* use callback to be able to enable the FPGA bridges after loading */
int fpga_loadbitstream(int devnum, char *fpgadata, size_t size,
                  bitstream_type bstype)
{
    int err;

    err = fpga_load(devnum, fpgadata, size, bstype);
    if (!err) {
        err = enableFPGA();
    }

    return err;
}

/* This function will be called after verification of the kernel image and before jumping into it */
void arch_preboot_os(void)
{
    /* inform uP1 about a successful load of the FPGA before jumping to kernel */
    if (!gpio_request(CONFIG_GPIO_FPGA_PRESENT, "fpga present")) {
        gpio_direction_output(CONFIG_GPIO_FPGA_PRESENT, 0);
    } else {
        puts("FPGA present notification failed\n");
    }
}

uint64_t getPhysRamSize(void)
{
    return(SZ_2G);
}

#endif
