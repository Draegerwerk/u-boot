/*
 *  (C) Copyright 2020 Draeger and Licensors, info@draeger.com
 *
 *  SPDX-License-Identifier: GPL-2.0+
 */

#include <common.h>
#include <fdt_support.h>
#include <i2c.h>
#include <i2c_eeprom.h>
#include <net.h>
#include <post.h>
#include <video.h>
#include <splash.h>
#include <bmp_logo.h>
#include <lcd.h>
#include <image.h>
#include <malloc.h>
#include <fs.h>
#include <init.h>
#include <u-boot/zlib.h>
#include <dm/ofnode.h>
#include <dm/uclass.h>
#include <irq_func.h>
#include <cpu_func.h>
#include <linux/ctype.h>
#include <asm/arch/imx-regs.h>
#include <asm/arch/iomux.h>
#include <asm/arch-mx6/imx-regs.h>
#include <asm/arch/mx6-pins.h>
#include <asm/arch/sys_proto.h>
#include <asm/mach-imx/gpio.h>
#include <asm/mach-imx/mxc_i2c.h>
#include <asm/mach-imx/iomux-v3.h>
#include <asm/mach-imx/sys_proto.h>
#include <asm/mach-imx/hab.h>

#include "../common/draeger_m48_pmstruct.h"
#include "../common/draeger_common.h"
#include "imx6m48.h"

#ifdef CONFIG_HW_DIAG
#include "hwdiag/cmd_ppm_eeprom.h"
#endif

#ifndef DO_DEPS_ONLY
#include "generated/version_autogenerated.h"
#endif

DECLARE_GLOBAL_DATA_PTR;

#define DEBUG_GPIO_BASE_ADDR GPIO5_BASE_ADDR
#define DEBUG_GPIO_INDEX     9

#define DEFAULT_FDT_FILE_MX6Q       "imx6q-m48.dtb"
#define DEFAULT_FDT_FILE_MX6DL      "imx6dl-m48.dtb"
#define DEFAULT_FDT_FILE_VAL        "imx6q-valenka.dtb"
#define SIGNATURE_SIZE 0x2020


#define GPIO_BOARD_COLD_RESET IMX_GPIO_NR(1, 2)  /* external cold reset GPIO1_IO02 */
#define GPIO_BOARD_WARM_RESET IMX_GPIO_NR(4, 30) /* external warm reset GPIO1_IO027 */
#define GPIO_DEBUG            IMX_GPIO_NR(5, 9)  /* Jumper 1 switch serial output on/off */

#define MAX_IP_ADDR_SIZE 22

#define VALENKA_DRAM_BASE0  0x10000000
#define VALENKA_DRAM_SIZE0  0x40000000  /* 1 GB */
#define VALENKA_DRAM_BASE1  0x80000000
#define VALENKA_DRAM_SIZE1  0x40000000  /* 1 GB */

/* DDR3 4GB, (4GB - 256MB) = 3840MB, is the maximum accessible memory */
#define VALENKA3_4GB_DRAM_SIZE  (SZ_4G - SZ_256M)

PmBootData* m48PmData = (PmBootData*) CFG_SYS_PMSTRUCT_ADDR;
/* create handover structure in OCRAM behind bootData */
struct splHandoverT * splHandoverData = (struct splHandoverT*)  (((PmBootData*) CFG_SYS_PMSTRUCT_ADDR) + 1);

bool isM48withUp2 (void)
{
    bool is = false;

    switch (splHandoverData->boardVersion) {
        case M48_1_PRE: /* fallthrough */
        case M48_3_PRE: /* fallthrough */
        case M48_1_PROD: /* fallthrough */
        case M48_3_PROD: /* fallthrough */
        case M48_3_QUADP: /* fallthrough */
            is = true;
            break;
        default:;
    }
    return is;
}



#ifndef CONFIG_SPL_BUILD

/*
 * isValenka() - determines whether it is Valenka type of board
 *
 * Returns true if it is Valenka type of board else false
 *
 */
bool isValenka(void)
{
    bool is = false;

    switch (splHandoverData->boardVersion) {
        case VALENKA_IMX6Q_SSPPM:      /* fallthrough */
        case VALENKA_IMX6Q_MOUNT:      /* fallthrough */
            is = true;
            break;
        default:;
    }
    return is;
}

/*
 * hasVal3Som() - determines whether the board has a Valenka3 SOM
 *
 * Returns true if the board has a Valenka3 SOM else false
 *
 */
static bool hasVal3Som(void)
{
    if ((splHandoverData->somVersion == VALENKA_3_2GB_SOM) ||
        (splHandoverData->somVersion == VALENKA_3_4GB_SOM))
    {
        return true;
    }
    else
    {
        return false;
    }
}

/*
 * isValenkaSsppm() - determines whether it is Valenka SSPPM type of board
 *
 * Returns true if it is Valenka SSPPM type of board else false
 *
 */
static bool isValenkaSsppm(void)
{
    bool is = false;

    switch (splHandoverData->boardVersion) {
        case VALENKA_IMX6Q_SSPPM:
            is = true;
            break;
        default:;
    }
    return is;
}

/*
 * isValenkaMount() - determines whether it is Valenka Mount type of board
 *
 * Returns true if it is Valenka Mount type of board else false
 *
 */
static bool isValenkaMount(void)
{
    bool is = false;

    switch (splHandoverData->boardVersion) {
        case VALENKA_IMX6Q_MOUNT:
            is = true;
            break;
        default:;
    }
    return is;
}

static bool isM48 (void)
{
    bool is = false;

    switch (splHandoverData->boardVersion) {
        case M48_1_PRE:  /* fallthrough */
        case M48_2_PRE:  /* fallthrough */
        case M48_3_PRE:  /* fallthrough */
        case M48_1_PROD: /* fallthrough */
        case M48_2_PROD: /* fallthrough */
        case M48_3_PROD: /* fallthrough */
        case M48_3_QUADP: /* fallthrough */
            is = true;
            break;
        default:;
    }
    return is;
}

/**
 * @brief Return the physical RAM size of the SOM
 *
 */
uint64_t getPhysRamSize(void)
{
    if (hasVal3Som() && (splHandoverData->somVersion == VALENKA_3_4GB_SOM))
    {
        return(SZ_4G);
    }
    else
    {
        return(SZ_2G);
    }
}

/**
 * @brief Debug command to see internal Valenka3 memory configuration
 *
 */
static int do_vinfo(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
{
    printf("val   = %d\n", isValenka());
    printf("val3  = %d\n", hasVal3Som());
    printf("ssppm = %d\n", isValenkaSsppm());
    printf("mount = %d\n", isValenkaMount());

    if (splHandoverData->somVersion == VALENKA_2_SOM)
        printf("som = %s\n", "Val2-2GB");
    else if (splHandoverData->somVersion == VALENKA_3_2GB_SOM)
        printf("som = %s\n", "Val3-2GB");
    else if (splHandoverData->somVersion == VALENKA_3_4GB_SOM)
        printf("som = %s\n", "Val3-4GB");
    else
        printf("som = UNKNOWN?\n");

    printf("DRAM[0].start = 0x%08lX\n", gd->bd->bi_dram[0].start);
    printf("DRAM[0].size  = 0x%08lX\n",  gd->bd->bi_dram[0].size);
    printf("DRAM[1].start = 0x%08lX\n", gd->bd->bi_dram[1].start);
    printf("DRAM[1].size  = 0x%08lX\n",  gd->bd->bi_dram[1].size);

    printf("getPhysRamSize = %llu\n", getPhysRamSize());
    printf("gd->ram_size   = %lu\n", gd->ram_size);

    printf("getPmMemoryRegionInDDR3() = 0x%08X\n", (uint32_t) getPmMemoryRegionInDDR3());

    return 0;
}

U_BOOT_CMD(
	vinfo,	5,	1,	do_vinfo,
	"debug/test",
	"[start [end [pattern [iterations]]]]"
);

void fdt_fixup_version_info(void *fdt)
{
#if defined(BUILD_TAG)
    const char *global_build_id = BUILD_TAG;
#else
    const char *global_build_id = "private";
#endif
    int ret = fdt_node_offset_by_compatible(fdt, -1, isValenka() ? "draeger,valenka_boardservice" : "draeger,boardservice");

    if (ret >= 0) {
        int off = ret;

        ret = fdt_setprop(fdt, off, "preloader-version", splHandoverData->preloaderVersion, strlen((const char*) splHandoverData->preloaderVersion) + 1);
        if (ret) {
            printf("Unable to update preloader-version property, err=%s\n", fdt_strerror(ret));
        }

        ret = fdt_setprop(fdt, off, "bootloader-version", global_build_id, strlen(global_build_id) + 1);
        if (ret) {
            printf("Unable to update bootloader-version property, err=%s\n", fdt_strerror(ret));
        }
    } else {
        printf("Unable to find boardservice node, err=%s\n", fdt_strerror(ret));
    }
}

void fdt_fixup_screen_configuration(void *fdt)
{

#define MAX_DISPLAY_NAME_LEN   20
#define MAX_NUMBER_OF_DISPLAYS  2

    int i;
    char env_name[MAX_DISPLAY_NAME_LEN];
    const char * env_display;

    for (i=0; i < MAX_NUMBER_OF_DISPLAYS; i++) {
        snprintf(env_name, MAX_DISPLAY_NAME_LEN, "panel-%d", i);
        env_display = env_get(env_name);
        if (env_display) {
            do_fixup_by_path(fdt, "/imx6/fbdev", env_name, env_display, strlen(env_display) + 1, 1);
        }
    }
}

static int read_mac_from_eeprom(void)
{
    int off, ret;
    uchar buf[28];
    char str[18];
    unsigned int crc = 0;
    struct udevice *dev;

    off = fdt_path_offset(gd->fdt_blob, "eeprom_mac");
    if (off < 0) {
        printf("%s: No eeprom_mac path offset\n", __func__);
        return off;
    }

    ret = uclass_get_device_by_of_offset(UCLASS_I2C_EEPROM, off, &dev);
    if (ret) {
        printf("Cannot find EEPROM!\n");
        return ret;
    }

    ret = i2c_eeprom_read(dev, CFG_SYS_I2C_MAC_OFFSET, buf, sizeof(buf));

    /* Read MAC addresses from EEPROM */
    if (ret) {
        printf("\nEEPROM @ 0x%02x read FAILED!!!\n",
            CONFIG_SYS_I2C_EEPROM_ADDR);
    }
    else {
        uint32_t crc_buf;
        int      hasNoCrc = 0;

        memcpy(&crc_buf, &buf[24], sizeof(uint32_t));

        if (isValenka()) {
            /* Valenka boards do not have a MAC CRC */
            hasNoCrc = 1;
        }

        if (hasNoCrc || crc32(crc, buf, 24) == crc_buf) {
            printf("Reading MAC from EEPROM\n");
            memset(str, 0xFF, 6);
            if (memcmp(buf, str, 6)) {
                sprintf(str,
                    "%02X:%02X:%02X:%02X:%02X:%02X",
                    buf[0], buf[1],
                    buf[2], buf[3],
                    buf[4], buf[5]);
                env_set("ethaddr", str);
            }
        }
        else {
            printf("EEPROM MAC CRC failed\n");
        }
    }

    return 0;
}

static int do_setmacaddr (struct cmd_tbl *cmdtp, int flag, int argc, char * const argv[])
{
    int off, ret, mac_no;
    uchar buf[28];
    unsigned char str[18];
    struct udevice *dev;

    if (! isM48()) {
        printf("Error! setmacaddr for hardware not supported\n");
        return -1;
    }

    if (argc != 3)
        return -1;

    if ((mac_no = simple_strtoul(argv[1], NULL, 10)) > 3) {
        printf ("MAC offset %d too high (valid values 0 -3)\n", mac_no);
        return 0;
    }

    string_to_enetaddr (argv[2], str);

    off = fdt_path_offset(gd->fdt_blob, "eeprom_mac");
    if (off < 0) {
        printf("%s: No eeprom_mac path offset\n", __func__);
        return off;
    }

    ret = uclass_get_device_by_of_offset(UCLASS_I2C_EEPROM, off, &dev);
    if (ret) {
        printf("Cannot find EEPROM!\n");
        return ret;
    }

    /* Read MAC addresses from EEPROM */
    if (!ret)
        ret = i2c_eeprom_read(dev, CFG_SYS_I2C_MAC_OFFSET, buf, sizeof(buf));

    if (ret) {
        printf("\nEEPROM @ 0x%02x read FAILED!!!\n",
            CONFIG_SYS_I2C_EEPROM_ADDR);
    }
    else {
        uint32_t crc_buf;

        memcpy(&crc_buf, &buf[24], sizeof(uint32_t));
        if (crc32(0, buf, 24) != crc_buf) {
            printf ("The EEPROM MAC area is corrupted...erasing\n");
            memset (buf, 0xFF, 28);
        }

        memcpy ((void *)(buf + 6 * mac_no), (void *)str, 6);
        crc_buf = crc32(0, buf, 24);
        memcpy ((void *)(buf + 24), (void *)(&crc_buf), sizeof(uint32_t));

        if (i2c_eeprom_write(dev, CFG_SYS_I2C_MAC_OFFSET, buf, sizeof(buf))) {
            printf("\nEEPROM @ 0x%02x write FAILED!!!\n",
                CONFIG_SYS_I2C_EEPROM_ADDR);
        }
        else {
            printf("MAC %s was written at offset %d\n", argv[2], mac_no);
        }
    }
    return 0;
}

U_BOOT_CMD(
    setmacaddr,	3,	1,	do_setmacaddr,
    "Set one of the 4 MAC addresses in EEPROM.",
    "Set one of the 4 MAC addresses in EEPROM. \n"
    "Only 4 MAC adresses can be written in EEPROM \n"
    "The one at offset 0 will be used as the interface MAC \n"
    "setmacaddr offset value"
);


static int boardrev (struct cmd_tbl *cmdtp, int flag, int argc, char * const argv[])
{
    int ret;
    uint16_t ver;
    struct udevice *dev;

    if (! isM48()) {
        printf("Error! boardrev for hardware not supported\n");
        return -1;
    }

    ret = i2c_get_chip_for_busnum(CONFIG_SYS_EEPROM_BUS_NUM,
        CONFIG_SYS_I2C_EEPROM_ADDR, 1, &dev);

    /* Read MAC addresses from EEPROM */
    if (!ret)
        ret = dm_i2c_read(dev, CFG_SYS_I2C_BOARD_REV_OFFSET, (uchar *) &ver, sizeof(ver));

    if (ret) {

        printf("\nEEPROM @ 0x%02x read @ 0x%02x FAILED!!!\n",
            CONFIG_SYS_I2C_EEPROM_ADDR, CFG_SYS_I2C_BOARD_REV_OFFSET);
        return ret;
    }

    printf ("Board revision %d.%d\n", *((char *)(&ver)), *((char *)(&ver) + 1));

    return 0;
}

U_BOOT_CMD(
    boardrev,   1,  1,  boardrev,
    "Board Revision Number.",
    "Board Revision Number. \n" \
    "boardrev"
);


static int setboardrev (struct cmd_tbl *cmdtp, int flag, int argc, char * const argv[])
{
    int ret;
    uint16_t ver;
    struct udevice *dev;
    unsigned long major;
    unsigned long minor;

    if (! isM48()) {
        printf("Error! setboardrev for hardware not supported\n");
        return 1;
    }

    if (argc != 3) {
        printf("Error! wrong number of parameters\n");
        return 1;
    }

    major = simple_strtoul(argv[1], NULL, 10);
    minor = simple_strtoul(argv[2], NULL, 10);

    if (major > 0xff || minor > 0xff) {
        printf ("Major or Minor numbers must be lower than 255\n");
        return 1;
    }

    ver = (uint16_t) (minor << 8) + (uint16_t) major;


    ret = i2c_get_chip_for_busnum(CONFIG_SYS_EEPROM_BUS_NUM,
        CONFIG_SYS_I2C_EEPROM_ADDR, 1, &dev);

    if (!ret)
        ret = dm_i2c_write(dev, CFG_SYS_I2C_BOARD_REV_OFFSET, (uint8_t*) &ver, sizeof(ver));

    if (ret) {
        printf("\nEEPROM @ 0x%02x write FAILED!!!\n",
            CFG_SYS_I2C_BOARD_REV_OFFSET);
        return ret;
    }

    return 0;
}

U_BOOT_CMD(
    setboardrev,    3,  1,  setboardrev,
    "Set Board Revision Number.",
    "Set Board Revision Number. \n"
    "setboardrev major minor"
);

char* get_conf_name(void)
{
    char *conf_name  = NULL;
    char *conf_name_env = env_get("conf_name");

    if (check_name(conf_name_env, CMD_BUF_SIZE)) {
        conf_name = conf_name_env;
    } else {
        if (isM48()) {
            if (is_cpu_type(MXC_CPU_MX6Q) || is_cpu_type(MXC_CPU_MX6QP)) {
                conf_name = "m48q";
            } else {
                conf_name = "m48dl";
            }
        }
        else if (isValenkaSsppm()) {
            conf_name = "ssppm";
        } else if (isValenkaMount()) {
            conf_name = "mount";
        }
    }
    return conf_name;
}

const char * get_ftd_name(void)
{
    const char *fdt_name;

    switch (splHandoverData->boardVersion) {
		case M48_1_PRE: /* fallthrough */
		case M48_1_PROD: /* fallthrough */
		case M48_2_PRE: /* fallthrough */
		case M48_2_PROD:
			fdt_name = DEFAULT_FDT_FILE_MX6DL;
			break;
		case M48_3_PRE: /* fallthrough */
		case M48_3_PROD: /* fallthrough */
        case M48_3_QUADP:
            fdt_name = DEFAULT_FDT_FILE_MX6Q;
			break;
		case VALENKA_IMX6Q_SSPPM: /* fallthrough */
		case VALENKA_IMX6Q_MOUNT:
            fdt_name = DEFAULT_FDT_FILE_VAL;
			break;
        default:
            fdt_name = "unknown";
    }
    return fdt_name;
}

int start_itb_image(void)
{
    char *conf_name = NULL;
    conf_name = get_conf_name();

    snprintf(cmdbuf, CMD_BUF_SIZE, "bootm %x%s%s", CONFIG_SYS_LOAD_ADDR,
        conf_name ? "#" : "", conf_name ? conf_name : "");
    if (run_command(cmdbuf, 0)) return -1;
    return 0;
}

int load_extra_images_from_partition(int partition)
{
    return 0;
}

int load_extra_images_from_tftp(void)
{
    return 0;
}

int authenticate_and_start_fit_image(ulong image_size)
{
    if ((image_size <= SIGNATURE_SIZE) ||
        imx_hab_authenticate_image(CONFIG_SYS_LOAD_ADDR, image_size, image_size - SIGNATURE_SIZE)) {
        puts("ERROR:  image authentication fail\n");
        return -1;
    }

    return start_itb_image();

    return 0;
}

int authenticate_and_start_legacy_image(ulong kernel_size, ulong fdt_size)
{
    /* SIGNATURE_SIZE = IVT_SIZE + CSF_PAD_SIZE */
    if (
        (kernel_size <= SIGNATURE_SIZE) ||
        (fdt_size    <= SIGNATURE_SIZE) ||
        ( imx_hab_authenticate_image(CONFIG_SYS_LOAD_ADDR, kernel_size, kernel_size - SIGNATURE_SIZE)) ||
        ( imx_hab_authenticate_image(CFG_SYS_FDT_ADDR, fdt_size, fdt_size - SIGNATURE_SIZE )))
        return -1;

    return start_legacy_image();
}

int start_kernel_image(ulong kernel_size, ulong fdt_size)
{
    if (fdt_size == 0) /* no fdt_size given --> fit image */
        return authenticate_and_start_fit_image(kernel_size);
    else
        return authenticate_and_start_legacy_image(kernel_size, fdt_size);
}

static void rotate_logo_180(unsigned char *buf)
{
	unsigned char tmp;
	unsigned char *from;
	unsigned char *to;

	for (from = &buf[0], to = &buf[BMP_LOGO_HEIGHT * BMP_LOGO_WIDTH - 1];
			to > from; from ++, to --) {
		tmp = *from;
		*from = *to;
		*to = tmp;
	}
}


int display_error_message(void)
{
	struct bmp_header *header;

	if (ofnode_conf_read_bool("rotate_screen")) {
		header = (struct bmp_header *)bmp_logo_bitmap;
		rotate_logo_180(bmp_logo_bitmap + header->data_offset);
	}
	bmp_display((ulong)&bmp_logo_bitmap[0], BMP_ALIGN_CENTER, BMP_ALIGN_CENTER);
	printf("Device failure !\n");
	return 1;
}

/* This function replaces the first occurrence of a whitespace character in str with a
 * zero termination character */
static void terminateStringAtFirstWhitespace(char *const str)
{
    unsigned int i;
    size_t len = strlen(str);
    for(i = 0; i < len; ++i)
    {
        if(isspace(str[i]))
        {
            str[i] = '\0';
            break;
        }
    }
}

/* Null on error, if found returned memory needs to be freed by caller */
static char * findValueOfKeyInEnvironment(const char *keyString, const char *searchBuffer, const size_t sizeInByte)
{
    char * ret = NULL;
    char * found = NULL;
    char * startOfValue = NULL;
    char * buffer = NULL;
    size_t lengthOfValue = 0;
    found = strstr(searchBuffer, keyString);
    if(found)
    {
        startOfValue = found + strlen(keyString);
        while(isblank(*startOfValue))
        {
            startOfValue++;
        }
        found = strchr(startOfValue,(int)';');
        if(found)
        {
            lengthOfValue = found - startOfValue;
            buffer = malloc(lengthOfValue+1);
            if(buffer)
            {
                strncpy(buffer, startOfValue, lengthOfValue+1);
                /* terminate string at the end */
                buffer[lengthOfValue] = 0;
                /* remove whitespace chars that might be to the left of the string termination
                 * e.g. \r\n*/
                terminateStringAtFirstWhitespace(buffer);
                ret = buffer;
            }
        }

    }
    return ret;
}

static int isValidIpV4Address(const char *const ip)
{
    const unsigned long maxNum = 255; /* max number within section */
    const unsigned int numberOfSections = 4;   /* sections per ip addr */
    const char *delimiter = "."; /* delimiter of sections */
    unsigned long num;
    unsigned int flag = 1;
    unsigned int counter=0;
    if(!ip)
    {
        return 0;
    }
    char *workingCopy = strdup(ip);
    if(!workingCopy)
    {
        return 0;
    }
    char* p = strtok(workingCopy, delimiter);

    while (p && flag )
    {
        if(strict_strtoul(p, 10, &num) != 0)
        {
            flag = 0;
            break;
        }
        if (num>=0 && num<=maxNum && (counter++<numberOfSections))
        {
            flag=1;
            p=strtok(NULL, delimiter);
        }
        else
        {
            flag=0;
            break;
        }
    }
    free(workingCopy);
    return flag && (counter==numberOfSections);
}

static int isValidSubnetmask(const char *const mask)
{
    unsigned long num;
    const unsigned int numBase = 16;
    const unsigned long maxNum = 0xFFFFFFFF;
    if(!mask)
    {
        return 0;
    }
    /* check if the subnet mask is in the form of e.g. FFFFFF00 */
    if(strict_strtoul(mask, numBase, &num) == 0)
    {
        return num <= maxNum;
    }
    return 0;
}

typedef struct
{
	const char *keyString;
	const char *envString;
	char *valueString;
	int(*checkerFunction)(const char *const); /* returns !0 when valid */
	int isValid;
} m48EnvParseEntry;

static m48EnvParseEntry m48EnvIpAddrValue    = {"ipaddr",   "ipaddr",    NULL, &isValidIpV4Address, 0};
static m48EnvParseEntry m48EnvServerIpValue  = {"serverip", "serverip",  NULL, &isValidIpV4Address, 0};
static m48EnvParseEntry m48EnvGatewayIpValue = {"gwip",     "gatewayip", NULL, &isValidIpV4Address, 0};
static m48EnvParseEntry m48EnvNetMaskValue   = {"netmask",  "netmask",   NULL, &isValidSubnetmask, 0};

static m48EnvParseEntry *const m48EnvParseArray[] = {&m48EnvIpAddrValue,
                                                     &m48EnvServerIpValue,
                                                     &m48EnvGatewayIpValue,
                                                     &m48EnvNetMaskValue};

static void parseBootEnvScript(void)
{
    ulong addr;
    ulong *data;
    const image_header_t *hdr;
    const char *interfaceName = "mmc";
    const char *devicePartitionString = "0:1";
    const char *scriptName = "bootenv.scr";
    const int scriptOffsetOnBlkDevice = 0;
    const int scriptMaxSizeInBytes = 2048;
    const char *textStart = NULL;
    size_t textSize = 0;
    unsigned int entryItr = 0;
    unsigned int injectionAllowed = 1;
    loff_t actread;

    if(!fs_set_blk_dev(interfaceName, devicePartitionString, FS_TYPE_FAT))
    {
        if(fs_exists(scriptName))
        {
            printf("\n%s detected. Start parsing\n", scriptName);
            /* fs_exists calls fs_close() therefore a new fs_set_blk_dev() is necessary */
            fs_set_blk_dev(interfaceName, devicePartitionString, FS_TYPE_FAT);

            /* reuse address for loading the flattened device tree */
            addr = CONFIG_SYS_LOAD_ADDR;

            /* clear RAM content
             * The scriptMaxSizeInBytes+1 ensures that the RAM area is null terminated even if the
             * file doesn't contain any 0's and/or is scriptMaxSizeInBytes large.
             * This is a safety precaution due to the use of strchr function which relies on zero terminated strings
             */
            memset((void *)addr, 0, scriptMaxSizeInBytes+1);

            if (fs_read(scriptName , addr, scriptOffsetOnBlkDevice, scriptMaxSizeInBytes, &actread) == 0 &&
                actread >= sizeof(image_header_t)) {


                hdr = (const image_header_t *)addr;
                if(image_check_magic(hdr))
                {
                    if(   image_check_hcrc(hdr)
                        && image_check_dcrc(hdr)
                        && image_check_type(hdr, IH_TYPE_SCRIPT))
                    {
                        data = (ulong *)image_get_data(hdr);
                        /*
                         * scripts are just multi-image files with one component, seek
                         * past the zero-terminated sequence of image lengths to get
                         * to the actual image data
                         */
                        while (*data++);
                        textStart = (const char *)data;
                        textSize = strlen(textStart)+1;
                        /* perform the parsing */
                        for(entryItr=0; entryItr < ARRAY_SIZE(m48EnvParseArray); ++entryItr)
                        {
                            m48EnvParseArray[entryItr]->valueString = findValueOfKeyInEnvironment(m48EnvParseArray[entryItr]->keyString, textStart, textSize);
                            m48EnvParseArray[entryItr]->isValid = m48EnvParseArray[entryItr]->checkerFunction(m48EnvParseArray[entryItr]->valueString);
                            /* only in case all values are found and valid the injection is granted*/
                            if(m48EnvParseArray[entryItr]->isValid == 0)
                            {
                                printf("Parsing of key: \"%s\" failed\n", m48EnvParseArray[entryItr]->keyString);
                                printf("Parsed value: \"%s\"\n", m48EnvParseArray[entryItr]->valueString ? m48EnvParseArray[entryItr]->valueString : "NULL");
                                printf("Skip parsing\n");
                                injectionAllowed = 0;
                                break;
                            }
                        }

                        /* inject into environment in RAM */
                        for(entryItr=0; injectionAllowed && (entryItr < ARRAY_SIZE(m48EnvParseArray)); ++entryItr)
                        {
                            if(env_set(m48EnvParseArray[entryItr]->envString, m48EnvParseArray[entryItr]->valueString) != 0)
                            {
                                injectionAllowed = 0;
                                printf("Injection into RAM failed\n");
                                printf("key: %-*s = %s\n",
                                    strlen("gatewayip"),
                                    m48EnvParseArray[entryItr]->envString,
                                    m48EnvParseArray[entryItr]->valueString);
                                printf("Skip parsing\n");
                                break;
                            }
                            printf("Injected into RAM\n");
                            printf("key: %-*s = %s\n",
                                strlen("serverip"),
                                m48EnvParseArray[entryItr]->envString,
                                m48EnvParseArray[entryItr]->valueString);
                        }
                        /* store environment in RAM on persistent memory */
                        if(injectionAllowed)
                        {
                            printf("Parsing successful. Store environment on persistent memory\n");
                            env_save();
                        }
                        /* cleanup */
                        for(entryItr=0; entryItr < ARRAY_SIZE(m48EnvParseArray); ++entryItr)
                        {
                            if(m48EnvParseArray[entryItr]->valueString)
                            {
                                free(m48EnvParseArray[entryItr]->valueString);
                            }
                        }
                    }
                    else
                    {
                        printf("Image integrity check failed\n");
                        printf("Header CRC check: %s\n" , image_check_hcrc(hdr) ? "OK" : "failed");
                        printf("Payload CRC check: %s\n", image_check_dcrc(hdr) ? "OK" : "failed");
                        printf("Image type: %s\n"       , image_check_type(hdr, IH_TYPE_SCRIPT) ? "OK" : "wrong type");
                        printf("Skip parsing\n");
                    }
                }
                else
                {
                    printf("Bad image magic detected. Skip parsing\n");
                }
            } else {
                printf("reading %s failed\n", scriptName);
            }
        }
        else
        {
            printf("\n%s not detected. Skip parsing\n", scriptName);
        }
    }
}



#endif /* CONFIG_SPL_BUILD */

int board_mmc_get_env_dev(int port)
{
    /*
     * Valenka: USDHC port 1 (USDHC2) = MMC device 0 (SD)
     * M48:     USDHC port 2 (USDHC3) = MMC device 0 (SD)
     * Valenka: USDHC port 3 (USDHC4) = MMC device 1 (eMMC)
     */
    if (port == 1 || port == 2)
    {
        return 0;
    }
    else
    {
        return 1;
    }
}

/*
 * Get the MMC device that is used to boot the uP
 */
int getBootMmcDevice(void)
{
    struct src *psrc = (struct src *)SRC_BASE_ADDR;
    int port = (readl(&psrc->sbmr1) >> 11) & 0x3;

    return board_mmc_get_env_dev(port);
}

static unsigned int srk1IsRevoked(void)
{
    const uint32_t SRK_1_MASK = 1;
    const uint32_t SRK_1_HAS_BEEN_REVOKED_VAL = 1;
    volatile void __iomem *srkRevokeShadowRegisterAddr;
    u32 srkRevokeShadowRegisterValue;
    srkRevokeShadowRegisterAddr = (volatile void __iomem *)(OCOTP_BASE_ADDR + 0x6F0);
    srkRevokeShadowRegisterValue = readl(srkRevokeShadowRegisterAddr) & SRK_1_MASK;
    return srkRevokeShadowRegisterValue == SRK_1_HAS_BEEN_REVOKED_VAL ? 1 : 0;
}

static unsigned int boardSecurityStateRequiresSilentBoot(void)
{
    enum hab_config config  = 0;
    enum hab_state state    = 0;
    unsigned int  isRequired      = 0;
    hab_rvt_report_status_t *hab_rvt_report_status;
    hab_rvt_report_status = (hab_rvt_report_status_t *)HAB_RVT_REPORT_STATUS;
    if(imx_hab_is_enabled())
    {
        isRequired = 1;
        (void)hab_rvt_report_status(&config, &state);
        if(   (config == HAB_CFG_RETURN)
            ||(config == HAB_CFG_OPEN  ))
        {
            isRequired = 0;
        }
        else if (config == HAB_CFG_CLOSED)
        {
            if(!srk1IsRevoked())
            {
                isRequired = 0;
            }
        }
    }
    return isRequired;
}

unsigned int silentBootIsRequired(void)
{
    unsigned int      isRequired;
    struct gpio_regs *regs;
    int               val;

    isRequired = 0;
    if(boardSecurityStateRequiresSilentBoot())
    {   /* required due to HAB settings */
        isRequired = 1;
    }
    else if (!isValenka())
    {
        /* The API gpio_get_value cannot be used because its driver is */
        /* not yet initialized when board_early_init_f is called.     */
        /* board_early_init_f calls this function.                     */
        regs = (struct gpio_regs *)DEBUG_GPIO_BASE_ADDR;
        val = (readl(&regs->gpio_psr) >> DEBUG_GPIO_INDEX) & 0x01;

        if (val)
        {
            /* required due to debug jumper setting */
            isRequired = 1;
        }
    }
    return isRequired;
}

/*
 * get_imx_wdog_wrsr() - reads and returns content of Watchdog Reset Status
 *                       Register for WDOG1 (WDOG1_WRSR)
 */
u16 get_imx_wdog_wrsr (void)
{
    u16 wdog1_wrsr = -1;

    struct wdog_regs* wdog1 = (struct wdog_regs *)WDOG1_BASE_ADDR;

    /* Read Watchdog Reset Status Register for WDOG1 */
    wdog1_wrsr = readw(&wdog1->wrsr);

    return wdog1_wrsr;
}

/******************************************************************************
 * u-boot hooks
 *****************************************************************************/

int board_early_init_f(void)
{
#ifndef CONFIG_HAB_REVOCATION_TEST_IMAGE
    if(silentBootIsRequired())
    {
        gd->flags |= (GD_FLG_SILENT | GD_FLG_DISABLE_CONSOLE);
    }
#endif
    return 0;
}


#ifndef CONFIG_SPL_BUILD

int board_fit_config_name_match(const char *name)
{
    char* boardName;

    debug("M48 board_fit_config_name_match\n");

    switch (splHandoverData->boardVersion)
    {
        case M48_3_PROD: /* fallthrough */
        case M48_3_PRE: /* fallthrough */
        case M48_3_QUADP:
            boardName = "imx6q-draeger-m48";
            break;
        case M48_1_PRE: /* fallthrough */
        case M48_2_PRE: /* fallthrough */
        case M48_1_PROD: /* fallthrough */
        case M48_2_PROD:
            boardName = "imx6dl-draeger-m48";
            break;
        case VALENKA_IMX6Q_SSPPM: /* fallthrough */
            boardName = "imx6q-draeger-valenka-ssppm";
            break;
        case VALENKA_IMX6Q_MOUNT: /* fallthrough */
            boardName = "imx6q-draeger-valenka-mount";
            break;
        default:
            boardName = "unknown";
    }

    return strcmp(name, boardName);
}

int checkboard(void)
{
#ifdef CONFIG_HAB_REVOCATION_TEST_IMAGE
    if(silentBootIsRequired())
    {
        printf("\n\n*************************************************************************\n");
        printf(    "Silent boot would have been enabled in standard U-Boot configuration\n");
        printf(  "\n*************************************************************************\n\n");
    }
#endif

    return 0;
}

int dram_init(void)
{
    if (splHandoverData->boardVersion == VALENKA_IMX6Q_SSPPM ||
        splHandoverData->boardVersion == VALENKA_IMX6Q_MOUNT)
    {
        if (splHandoverData->somVersion == VALENKA_3_4GB_SOM)
        {
            gd->ram_size = VALENKA3_4GB_DRAM_SIZE;
        }
        else
        {   /* Valenka2 or Valenka3 2GB */
            gd->ram_size = SZ_2G;
        }
    }
    else
    {
        gd->ram_size = get_ram_size((void *)CONFIG_SYS_SDRAM_BASE, PHYS_SDRAM_SIZE);
    }
    return 0;
}

int board_init(void)
{
    int post_boot_mode;
    u32 cause;
    char *vers;
    const char *token = "-draeger_";
    vers = strstr(U_BOOT_VERSION, token);
    vers +=1;

    debug("M48 board_init\n");
    m48PmData->timestamp_kernelloaded = CFG_SYS_ABS_TIME_OFFSET;
    m48PmData->bootmode = 0;

    snprintf((char*) m48PmData->uboot_version, sizeof(m48PmData->uboot_version), "%s", vers);

    post_boot_mode = post_bootmode_get(0);
    if (post_boot_mode == 0 || (post_boot_mode & POST_POWERON)) {
        m48PmData->startType = M48_START_TYPE_POWERUP;
    } else {
        cause = get_imx_reset_cause();

        if (cause & (RST_WARM | RST_WDOG | RST_JTAG_SW)) {
            m48PmData->startType = M48_START_TYPE_WARM_REBOOT;
        } else {
            m48PmData->startType = M48_START_TYPE_COLD_REBOOT;
        }
    }

    updateM48PmStructChecksum();

    return 0;
}

/*
 * Do not overwrite the console
 * Use always serial for U-Boot console
 */
int overwrite_console(void)
{
    debug("M48 overwrite_console\n");
    return 1;
}

int dram_init_banksize(void)
{
    if (isValenka())
	{
        if (hasVal3Som())
        {
            if (splHandoverData->somVersion == VALENKA_3_4GB_SOM)
            {
                gd->bd->bi_dram[0].start = VALENKA_DRAM_BASE0;
                gd->bd->bi_dram[0].size = VALENKA3_4GB_DRAM_SIZE;
                gd->bd->bi_dram[1].size = 0; /* invalid bi_ram entry */
            }
            else if (splHandoverData->somVersion == VALENKA_3_2GB_SOM)
            {
                gd->bd->bi_dram[0].start = VALENKA_DRAM_BASE0;
                gd->bd->bi_dram[0].size = SZ_2G;
                gd->bd->bi_dram[1].size = 0; /* invalid bi_ram entry */
            }
        }
        else
        {
            /* Valenka 2 - 2GB LPDDR2 */
            gd->bd->bi_dram[0].start = VALENKA_DRAM_BASE0;
            gd->bd->bi_dram[0].size = VALENKA_DRAM_SIZE0;
            gd->bd->bi_dram[1].start = VALENKA_DRAM_BASE1;
            gd->bd->bi_dram[1].size = VALENKA_DRAM_SIZE1;
        }
	}
	else
	{
		gd->bd->bi_dram[0].start = CONFIG_SYS_SDRAM_BASE;
		/* set size to real, so that vxWorks can use it */
		u64 ram_size  = (u64) get_ram_size((long *)CONFIG_SYS_SDRAM_BASE, (long) PHYS_SDRAM_SIZE);
		gd->bd->bi_dram[0].size = ram_size;

		gd->bd->bi_dram[1].size = 0; /* invalid bi_ram entry */
	}

	return 0;
}

int ft_board_setup(void *blob, struct bd_info *bd)
{
	fdt_fixup_version_info(blob);
	fdt_fixup_screen_configuration(blob);
#ifndef CONFIG_HAB_REVOCATION_TEST_IMAGE
    if(silentBootIsRequired()){
        fdt_fixup_serial_output(blob);
    }
#endif
	arch_fixup_fdt(blob);

	return 0;
}

int board_late_init(void)
{
    int ret;
    struct udevice *dev;
    char *altcon;

    debug("M48 board_late_init\n");

    altcon = env_get("altcon");
    if (altcon) {
        ret = uclass_get_device(UCLASS_SERIAL, 1, &dev);
        if (ret ) {
            puts("No alternate console\n");
        } else {
            env_set("stdin", altcon);
            env_set("stdout", altcon);
            env_set("stderr", altcon);
        }
    }

#ifdef CONFIG_HW_DIAG
    if (isValenkaSsppm()) {
        ppm_eeprom_init_env(PPM_UNIT_SSPPM);
    } else if (isValenkaMount()) {
        ppm_eeprom_init_env(PPM_UNIT_MOUNT);
    }
#endif

    read_mac_from_eeprom();

    if (gd->flags & GD_FLG_DISABLE_CONSOLE) m48PmData->verboseBoot = 0;
    else                                    m48PmData->verboseBoot = 1;

    /* Set defaults for some Valenka specific environment variables */
    if (isValenkaSsppm()) {
        if (!env_get("panel"))
            env_set("panel", "Tianma_1280x800-24@60");
    } else if (isValenkaMount()) {
        if (!env_get("panel"))
            env_set("panel", "hdmi-1280x800-32@60");
    }

    ret = uclass_get_device(UCLASS_VIDEO, 0, &dev);
    if (ret) {
        puts("No video\n");
    } else {
        video_sync(dev, false);
    }

    env_set("fdt_name", get_ftd_name());

    return 0;
}

int last_stage_init(void)
{

    if(gd->flags & GD_FLG_ENV_DEFAULT && isM48())
    {
        /*  will load the bootenv script to loadaddr
         *  therefore do not call after loading the kernel
         */
        parseBootEnvScript();
    }

    return 0;
}

#ifdef CONFIG_POST

/* power-on
 * |              uP1 reset both
 * |              |         uP2 reset both
 * |              |         |          run always
 * |              |         |          |             load kernel
 * |              |         |          |             |
 * v              v         v          v             v
 * |--------------|---------|----------|-------------|
 * |              |         |          |             |
 * |<---ts_post-->|<--time->|          |             |
 * |<---------ts_post------>|<--time-->|             |
 * |<--------------ts_post------------>|             |
 * |                        |                        |
 * |<-----ts_loaded-------->+<--------time---------->|
 */

/* time to wait for reboot of uP2 */
#define POST_REMOTE_WAIT_INTERVAL_1 1500
/* time to wait for reset triggered by uP2 */
#define POST_REMOTE_WAIT_INTERVAL_2 2000
/* time to wait after triggering reset before set to failure */
#define POST_REMOTE_WAIT_FAILURE    150

#ifdef CONFIG_SYS_POST_BSPEC1

int board_reset_post_test (int flags)
{
    int ints;
    ulong base,time;

    if ((m48PmData->post_board_reset.magic != BRESET_MAGIC) || ((flags & POST_MANUAL) != 0)) {
        /* PowerOn */
        m48PmData->post_board_reset.result = M48_TS_NOT_RUN;
        m48PmData->post_board_reset.state  = POST_BRESET_STATE_UP1_RESET;
        m48PmData->post_board_reset.magic  = BRESET_MAGIC;
        /* measured value at beginning, not deterministic */
        m48PmData->timestamp_post = 2 * CFG_SYS_ABS_TIME_OFFSET;
    }


    /* add time offset up to internal timer runs */
    m48PmData->timestamp_post += CFG_SYS_ABS_TIME_OFFSET;

    /* add the offset which has been already created by preceeding restarts */
    m48PmData->timestamp_kernelloaded = m48PmData->timestamp_post;

    /* for Valenka, we skip the reset test for now (PCSWORK-3410) */
    if (!isValenka() && m48PmData->post_board_reset.result == M48_TS_NOT_RUN) {
        switch (m48PmData->post_board_reset.state) {
            case POST_BRESET_STATE_UP1_RESET:
                if(isM48withUp2()) {
                    m48PmData->post_board_reset.state = POST_BRESET_STATE_UP2_RESET;
                } else {
                    m48PmData->post_board_reset.state = POST_BRESET_STATE_BOTH_DONE;
                }
                updateM48PmStructChecksum();

                while ((time = post_time_ms (0)) < POST_REMOTE_WAIT_INTERVAL_1) {;}	/* give other UP time to settle */

                post_log("hw reset time: %u ms\n", time);

                ints = disable_interrupts ();

                m48PmData->timestamp_post = m48PmData->timestamp_kernelloaded + post_time_ms (0);
                flush_dcache_all();

                if ((gpio_request(GPIO_BOARD_COLD_RESET, "cold-reset")) ||
                    (gpio_direction_output(GPIO_BOARD_COLD_RESET , 0)) ) {

                    post_log("hw reset : failed to access GPIO %u ", GPIO_BOARD_COLD_RESET);
                    m48PmData->post_board_reset.result = M48_TS_FAIL;
                    updateM48PmStructChecksum();
                    return 4;
                } else {
                    base = post_time_ms (0);
                    while ((time = post_time_ms (0)) < base + POST_REMOTE_WAIT_FAILURE)
                    {
                        /* timestamp_kernelloaded holds the timestamp_post after restart */
                        m48PmData->timestamp_post = m48PmData->timestamp_kernelloaded + post_time_ms (0);
                        flush_dcache_all();
                    }
                    post_log("hw reset time : %u ms, failed while waiting for own reset \n", time);
                }

                /* we should never reach this code if the test succeeds */
                if (ints) { enable_interrupts (); }

                m48PmData->post_board_reset.result = M48_TS_FAIL;
                m48PmData->timestamp_post = m48PmData->timestamp_kernelloaded;
                updateM48PmStructChecksum();

                return 1;
            case POST_BRESET_STATE_UP2_RESET:
                m48PmData->post_board_reset.state = POST_BRESET_STATE_BOTH_DONE;
                updateM48PmStructChecksum();


                post_log("\nhw reset test time : %u ms waiting for reboot from other UP\n", post_time_ms (0));
                while ((m48PmData->remoteDelay = post_time_ms (0)) < POST_REMOTE_WAIT_INTERVAL_2) {
                    /* timestamp_kernelloaded holds the timestamp_post after restart */
                    m48PmData->timestamp_post = m48PmData->timestamp_kernelloaded + post_time_ms (0);
                    flush_dcache_all();
                }
                post_log("hw reset time : %u ms, failed while waiting for reset from other UP\n", m48PmData->remoteDelay);

                /* reset to value after restart */
                m48PmData->timestamp_post = m48PmData->timestamp_kernelloaded;
                m48PmData->post_board_reset.result = M48_TS_FAIL;
                updateM48PmStructChecksum();

                return 2;
            case POST_BRESET_STATE_BOTH_DONE:
                m48PmData->post_board_reset.result = M48_TS_PASS;
                updateM48PmStructChecksum();
                post_log("remote delay : %u/%u ms \nPOST board_reset ", m48PmData->remoteDelay, POST_REMOTE_WAIT_INTERVAL_2);
                break;

            default:
                post_log("hw reset test out of state ");
                return 3;
        }
    }
    return 0;
}

#endif /* CONFIG_SYS_POST_BSPEC1 */


#ifdef CONFIG_SYS_POST_WATCHDOG

#define WDOG_WCR_WDE        (0x1 << 2)

int watchdog_post_test (int flags)
{
    int ints;
    ulong base,time;

    /* add the offset which has been already created by preceeding restarts */
    m48PmData->timestamp_kernelloaded = m48PmData->timestamp_post;

    struct wdog_regs* wdog1 = (struct wdog_regs *)WDOG1_BASE_ADDR;
    struct wdog_regs* wdog2 = (struct wdog_regs *)WDOG2_BASE_ADDR;
    debug("%s %x %x\n", __func__, flags, m48PmData->post_watchdog.magic);
    if ((m48PmData->post_watchdog.magic != SYS_WATCHDOG_MAGIC) || ((flags & POST_MANUAL) != 0)) {
        /* PowerOn */
        m48PmData->post_watchdog.magic  = SYS_WATCHDOG_MAGIC;
        m48PmData->post_watchdog.result = M48_TS_NOT_RUN;
        updateM48PmStructChecksum();

        initializePMSaveMemory();

        while ((time = post_time_ms (0)) < POST_REMOTE_WAIT_INTERVAL) {;}	/* give other UP time to settle */

        ints = disable_interrupts ();
        writew(1, &wdog1->wmcr);
        writew(1, &wdog2->wmcr);

        m48PmData->timestamp_post = m48PmData->timestamp_kernelloaded + time;
        flush_dcache_all();

        writew(WDOG_WCR_WDE, &wdog1->wcr);
        writew(WDOG_WCR_WDE, &wdog2->wcr);

        time = base = post_time_ms (0);
        while ((time-base) < 800) {
            m48PmData->timestamp_post = m48PmData->timestamp_kernelloaded + time;
            flush_dcache_all();
            time = post_time_ms (0);
        }

        /* we should never reach this code if the test succeeds */
        if (ints) { enable_interrupts (); }

        m48PmData->post_watchdog.result = M48_TS_FAIL;
        /* reset to value after restart */
        m48PmData->timestamp_post = m48PmData->timestamp_kernelloaded;
        updateM48PmStructChecksum();

        post_log("hw watchdog time : %u ms, failed ", time);
        return 2;

    } else {
        /* No PowerOn -> Reset */
        if (m48PmData->post_watchdog.result == M48_TS_NOT_RUN) {

            m48PmData->post_watchdog.result = M48_TS_PASS;

            /* add time offset up to internal timer runs */
            m48PmData->timestamp_post += CFG_SYS_ABS_TIME_OFFSET;
            m48PmData->timestamp_kernelloaded = m48PmData->timestamp_post;
            updateM48PmStructChecksum();
            checkPMSaveMemory();
        }
    }
    return 0;
}

#endif /* CONFIG_SYS_POST_WATCHDOG */

#endif /* CONFIG_POST */

#endif /* CONFIG_SPL_BUILD */
